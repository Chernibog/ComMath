import java.util.Scanner;

/**
 * Класс реализует решение системы линейных уравнений методом Жордана-Гаусса
 * с частичным выбором ведущего элемента (по столбцу).
 */
public class JordanHaussKek {
    public static void main(String[] args) {

        // Размер системы: n уравнений, n неизвестных
        final int n = 4;

        // Расширенная матрица: n строк, n+1 столбцов (последний — свободные члены)
        double[][] matrix_a = new double[n][n + 1];

        // Массив для хранения найденных решений x0, x1, ..., x_{n-1}
        double[] X = new double[n];

        // Создаём объект для ввода данных с клавиатуры
        Scanner scanner = new Scanner(System.in);

        // === Этап 1: Ввод расширенной матрицы ===
        System.out.println("Введите расширенную матрицу (" + n + "x" + (n+1) + "):");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n + 1; j++) {
                System.out.print("Элемент [" + i + "][" + j + "]: ");
                matrix_a[i][j] = scanner.nextDouble();
            }
        }

        // === Этап 2: Прямой ход метода Гаусса ===
        // Цель: привести матрицу к верхнетреугольному виду
        for (int k = 0; k < n; k++) {

            // === Шаг 2.1: Проверка и выбор ведущего элемента ===
            // Если текущий диагональный элемент близок к нулю — ищем ненулевой ниже
            if (Math.abs(matrix_a[k][k]) < 0.00001) {
                int m = k + 1;
                // Ищем первую строку ниже k-й, где элемент в k-м столбце не нулевой
                while (m < n && Math.abs(matrix_a[m][k]) < 0.00001) {
                    m++;
                }

                // Если не нашли — система вырождена (нет единственного решения)
                if (m >= n) {
                    System.out.println("Система не имеет единственного решения!");
                    return; // Завершаем программу
                }

                // Меняем местами строки k и m, чтобы поставить "хороший" ведущий элемент
                for (int j = 0; j < n + 1; j++) {
                    double temp = matrix_a[k][j];
                    matrix_a[k][j] = matrix_a[m][j];
                    matrix_a[m][j] = temp;
                }
            }

            // === Шаг 2.2: Приведение к треугольному виду (правило прямоугольника) ===
            // Для всех строк ниже k-й: обнуляем элементы под диагональю в k-м столбце
            for (int i = k + 1; i < n; i++) {
                // Для всех столбцов справа от k-го (включая столбец свободных членов)
                for (int j = k + 1; j < n + 1; j++) {
                    // Формула: A[i][j] = (A[i][j] * A[k][k] - A[k][j] * A[i][k]) / A[k][k]
                    // Это эквивалентно вычитанию строки, умноженной на коэффициент
                    matrix_a[i][j] = (matrix_a[i][j] * matrix_a[k][k] - matrix_a[k][j] * matrix_a[i][k]) / matrix_a[k][k];
                }
            }

            // Обнуляем элементы под диагональю в k-м столбце 
            for (int i = k + 1; i < n; i++) {
                matrix_a[i][k] = 0;
            }

            // === Шаг 2.3: Нормализация ведущей строки ===
            // Делим всю k-ю строку на ведущий элемент, чтобы на диагонали стал 1
            // (Это не обязательно, но упрощает обратный ход)
            for (int j = n; j >= k; j--) { // проходим справа налево (можно и слева направо)
                matrix_a[k][j] = matrix_a[k][j] / matrix_a[k][k];
            }

            // === Вывод промежуточного состояния матрицы после k-го шага ===
            System.out.println("\nПосле шага k=" + k + ":");
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n + 1; j++) {
                    System.out.printf("%8.3f ", matrix_a[i][j]); // форматированный вывод
                }
                System.out.println(); // новая строка после каждой строки матрицы
            }
        }

        // === Этап 3: Обратный ход метода Гаусса ===
        // Цель: найти значения неизвестных, начиная с последнего

        // Последнее уравнение: x[n-1] = свободный член (т.к. коэффициент при x[n-1] = 1)
        X[n - 1] = matrix_a[n - 1][n];

        // Идём с предпоследнего уравнения вверх
        for (int k = n - 2; k >= 0; k--) {
            // Берём свободный член как начальное значение
            X[k] = matrix_a[k][n];

            // Вычитаем уже найденные значения x_m, умноженные на их коэффициенты
            for (int m = k + 1; m < n; m++) {
                X[k] -= matrix_a[k][m] * X[m];
            }
        }

        // === Этап 4: Вывод решения ===
        System.out.println("\nРешение системы:");
        for (int i = 0; i < n; i++) {
            System.out.printf("x%d = %.5f\n", i, X[i]); // вывод с 5 знаками после запятой
        }

        scanner.close();
    }
}
